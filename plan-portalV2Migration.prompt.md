# Plan: Migrate Portal-Web to Portal-V2 with TanStack Router (Final)

Complete migration from React Router v7 to TanStack Router ecosystem with full TanStack integration: TanStack Store with persistence plugin and devtools (dev-only), TanStack Form with onBlur validation, centralized query key factory with tiered staleTime strategy, folder-based nested route structure using `/business/:businessDescriptor`, content-aware Suspense skeletons, smart error boundary retry with query refetch, and business-switch query invalidation.

## Steps

### 1. Clean Portal-V2 boilerplate and establish foundation

- Remove demo files: [src/routes/demo/](portal-v2/src/routes/demo/), [src/data/demo.punk-songs.ts](portal-v2/src/data/demo.punk-songs.ts), [src/lib/demo-store.ts](portal-v2/src/lib/demo-store.ts), [src/lib/demo-store-devtools.tsx](portal-v2/src/lib/demo-store-devtools.tsx), [src/components/Header.tsx](portal-v2/src/components/Header.tsx)
- Update [vite.config.ts](portal-v2/vite.config.ts): Remove TanStack Start plugin and Nitro (SSR disabled), keep TanStack Router plugin with client-only mode, configure Tailwind v4, set up path aliases for `@/*`, configure conditional build to exclude TanStack Store devtools from production bundle
- Copy design system: Port [src/index.css](portal-web/src/index.css) with IBM Plex Sans Arabic font, daisyUI v5 theme tokens (primary: #0D9488, secondary: #EAB308), Tailwind v4 CSS-first config, RTL-ready logical properties
- Add dependencies: `@tanstack/react-store`, `@tanstack/store-devtools` (devDependency only), `@tanstack/react-form`, `@tanstack/zod-form-adapter`, ky, i18next, react-i18next, date-fns, lucide-react, react-hot-toast, zod
- Configure [tsconfig.json](portal-v2/tsconfig.json): Add path aliases (`@/api/*`, `@/components/*`, `@/hooks/*`, `@/stores/*`, `@/lib/*`, `@/i18n/*`, `@/types/*`)
- Create [src/lib/storePersistence.ts](portal-v2/src/lib/storePersistence.ts): TanStack Store persistence plugin with localStorage backend, TTL support (check `lastFetched` timestamp, auto-clear expired data), automatic serialization/deserialization, type-safe storage keys (`kyora_business_prefs`, `kyora_metadata`, `kyora_onboarding_session`)

### 2. Set up authentication infrastructure and HTTP client

- Create [src/api/client.ts](portal-v2/src/api/client.ts): Port ky client with RFC 7807 ProblemDetails parsing, auto-refresh on 401 (singleton pattern prevents concurrent refresh calls), request deduplication (in-flight tracking with Map), token management (access in-memory, refresh in secure cookie), retry with exponential backoff (max 3s between attempts)
- Create [src/stores/authStore.ts](portal-v2/src/stores/authStore.ts): TanStack Store for auth state (`user`, `isAuthenticated`, `tokens`), actions (`login`, `logout`, `setUser`, `clearAuth`), no persistence (session restore via refresh token only), integrate with TanStack Store devtools only in development (conditional import wrapped in `if (import.meta.env.DEV)`)
- Update [src/router.tsx](portal-v2/src/router.tsx): Add router context type with `auth` (from authStore), `queryClient`, configure `defaultPreload: 'intent'` for hover prefetching, set up Suspense boundaries for route-level loading
- Create [src/api/auth.ts](portal-v2/src/api/auth.ts): Port auth endpoints (login, logout, refresh, forgot/reset password, OAuth) with typed response schemas, query options factory for auth queries with staleTime: 5 minutes
- Create [src/lib/auth.ts](portal-v2/src/lib/auth.ts): Session restoration logic (check refresh token cookie → call `/v1/auth/refresh` → restore user), token management helpers (`setTokens`, `clearTokens`, `hasValidToken`)

### 3. Migrate i18n system and create centralized query key factory with tiered staleTime

- Copy [src/i18n/](portal-web/src/i18n/): Port init.ts, config.ts, locales directory structure (ar/, en/ with common.json, errors.json, onboarding.json, translation.json)
- Initialize i18next before router in [src/main.tsx](portal-v2/src/main.tsx): Synchronous initialization, set document `dir` and `lang` attributes, ensure translations ready before render, conditionally initialize TanStack Store devtools (only in development, exclude from production bundle)
- Create [src/hooks/useLanguage.ts](portal-v2/src/hooks/useLanguage.ts): Port language switcher with cookie persistence (`kyora_language`), RTL detection (`isRTL`, `direction`), toggleLanguage helper, document attribute sync
- Create [src/lib/errorParser.ts](portal-v2/src/lib/errorParser.ts), [src/lib/translateError.ts](portal-v2/src/lib/translateError.ts): RFC 7807 ProblemDetails parser, i18n key extraction (`errors.http.*`, `errors.validation.*`), async translation helper
- Create [src/lib/queryKeys.ts](portal-v2/src/lib/queryKeys.ts): Centralized query key factory with nested structure and documented staleTime strategy - User profile: 5 minutes, Businesses list: 5 minutes, Selected business: 5 minutes, Customers list: 30 seconds, Customer details: 30 seconds, Orders: 15 seconds, Inventory: 1 minute, Analytics: 5 minutes, Metadata: 24 hours, include `businessScoped` helper to identify queries that should be invalidated on business switch

### 4. Create folder-based route structure with authentication

- Create [src/routes/\_\_root.tsx](portal-v2/src/routes/__root.tsx): Root layout with ErrorBoundary, Toaster (RTL-aware via `useLanguage`), QueryClient provider, authStore provider/context, outlet wrapped in Suspense with app-level skeleton fallback (content-aware: header skeleton + main content pulse), session restoration on mount
- Create authentication routes: [src/routes/auth/login.tsx](portal-v2/src/routes/auth/login.tsx), [src/routes/auth/forgot-password.tsx](portal-v2/src/routes/auth/forgot-password.tsx), [src/routes/auth/reset-password.tsx](portal-v2/src/routes/auth/reset-password.tsx), [src/routes/auth/oauth/callback.tsx](portal-v2/src/routes/auth/oauth/callback.tsx)
- Implement [auth/login.tsx](portal-v2/src/routes/auth/login.tsx): Route loader redirects if authenticated, TanStack Form with email/password fields + Zod validator (onBlur validation mode), integrate with authStore.login action, Google OAuth button, error translation with toast, Suspense boundary with content-aware skeleton (login form shape with pulse inputs)
- Implement [auth/oauth/callback.tsx](portal-v2/src/routes/auth/oauth/callback.tsx): Route loader handles OAuth (extract code/state from search params, call `/v1/auth/oauth/google`, set tokens, redirect to home or onboarding), content-aware loading skeleton (centered spinner with "Completing authentication..." message)
- Create [src/lib/routeGuards.ts](portal-v2/src/lib/routeGuards.ts): Reusable `requireAuth` function for `beforeLoad` hooks (check authStore.isAuthenticated, throw redirect to `/auth/login` with `from` search param if not authenticated)

### 5. Migrate onboarding flow with TanStack Store and Forms

- Create [src/stores/onboardingStore.ts](portal-v2/src/stores/onboardingStore.ts): TanStack Store for onboarding session (`sessionToken`, `stage`, `email`, `planId`, `businessData`, `paymentCompleted`), actions (`startSession`, `updateStage`, `setEmail`, `setPlan`, `setBusiness`, `clearSession`), integrate with persistence plugin (`kyora_onboarding_session` key, no TTL), integrate with TanStack Store devtools (dev-only)
- Create [src/api/onboarding.ts](portal-v2/src/api/onboarding.ts): Port complete onboarding API with TanStack Query mutations (`useStartOnboardingMutation`, `useSendOtpMutation`, `useVerifyOtpMutation`, `useSubmitBusinessMutation`, `useStartPaymentMutation`, `useCompleteOnboardingMutation`), use centralized query keys, no caching for mutations
- Create onboarding routes: [src/routes/onboarding/index.tsx](portal-v2/src/routes/onboarding/index.tsx) (layout), [src/routes/onboarding/plan.tsx](portal-v2/src/routes/onboarding/plan.tsx), [src/routes/onboarding/email.tsx](portal-v2/src/routes/onboarding/email.tsx), [src/routes/onboarding/verify.tsx](portal-v2/src/routes/onboarding/verify.tsx), [src/routes/onboarding/business.tsx](portal-v2/src/routes/onboarding/business.tsx), [src/routes/onboarding/payment.tsx](portal-v2/src/routes/onboarding/payment.tsx), [src/routes/onboarding/complete.tsx](portal-v2/src/routes/onboarding/complete.tsx), [src/routes/onboarding/oauth-callback.tsx](portal-v2/src/routes/onboarding/oauth-callback.tsx)
- Each onboarding route: Shared `beforeLoad` validates session from onboardingStore (redirect to plan if no session), TanStack Form for data collection with Zod validators (onBlur validation mode), integrate with onboarding mutations and store actions, progress indicator shows current stage, navigate to next step on success, Suspense boundary with content-aware skeleton (matching form structure: labels + pulse inputs + button)
- Create [src/components/templates/OnboardingLayout.tsx](portal-v2/src/components/templates/OnboardingLayout.tsx): Minimal layout with progress bar (percentage based on stage), language switcher (icon-only variant), outlet for step content

### 6. Migrate business and metadata state management with TanStack Store

- Create [src/stores/businessStore.ts](portal-v2/src/stores/businessStore.ts): TanStack Store for business state (`businesses`, `selectedBusinessDescriptor`, `sidebarCollapsed`), actions (`setBusinesses`, `selectBusiness`, `toggleSidebar`, `invalidateBusinessQueries`), integrate with persistence plugin for `selectedBusinessDescriptor` and `sidebarCollapsed` (no TTL), `businesses` not persisted (fetched fresh), integrate with TanStack Store devtools (dev-only), `selectBusiness` action triggers invalidation of all business-scoped queries
- Create [src/stores/metadataStore.ts](portal-v2/src/stores/metadataStore.ts): TanStack Store for metadata (`countries`, `currencies`, `phoneCodes`, `lastFetched`), actions (`setMetadata`, `clearMetadata`), integrate with persistence plugin (24-hour TTL), auto-clear stale cache on access, integrate with TanStack Store devtools (dev-only)
- Create [src/api/business.ts](portal-v2/src/api/business.ts): Port business endpoints with query hooks (`useBusinessesQuery`, `useBusinessQuery`, `useCreateBusinessMutation`, `useUpdateBusinessMutation`), use centralized query keys, set staleTime: 5 minutes (semi-static data), implement optimistic updates for mutations
- Create [src/api/metadata.ts](portal-v2/src/api/metadata.ts): Port metadata endpoint with cached query (`useMetadataQuery` with 24h staleTime), integrate with metadataStore for additional persistence layer
- Create [src/hooks/useAuth.ts](portal-v2/src/hooks/useAuth.ts): Custom hook to access authStore with React bindings (`useStore(authStore)`), expose `user`, `isAuthenticated`, `login`, `logout` helpers
- Create [src/lib/queryInvalidation.ts](portal-v2/src/lib/queryInvalidation.ts): Helper function `invalidateBusinessScopedQueries(queryClient, businessDescriptor)` that invalidates all queries marked as business-scoped in queryKeys factory (customers, orders, inventory, analytics for specific business)

### 7. Create business routes with folder nesting using singular naming

- Create [src/routes/index.tsx](portal-v2/src/routes/index.tsx): Home page with `beforeLoad` auth guard, route loader fetches user businesses (staleTime: 5 minutes), redirect to last selected business (`/business/:descriptor`) or show business selection hub, Suspense boundary with content-aware skeleton (business cards grid pulse)
- Create business routes with folder structure: [src/routes/business/$businessDescriptor.tsx](portal-v2/src/routes/business/$businessDescriptor.tsx) (parent layout), [src/routes/business/$businessDescriptor/index.tsx](portal-v2/src/routes/business/$businessDescriptor/index.tsx) (business home page), [src/routes/business/$businessDescriptor/customers/index.tsx](portal-v2/src/routes/business/$businessDescriptor/customers/index.tsx), [src/routes/business/$businessDescriptor/customers/$customerId.tsx](portal-v2/src/routes/business/$businessDescriptor/customers/$customerId.tsx)
- Implement business layout [business/$businessDescriptor.tsx](portal-v2/src/routes/business/$businessDescriptor.tsx): `beforeLoad` with `requireAuth`, validates business access (fetch business by descriptor, staleTime: 5 minutes), calls businessStore.selectBusiness which triggers invalidation of all business-scoped queries, wraps children with DashboardLayout template (Sidebar, Header, BottomNav), Suspense boundary around outlet with content-aware skeleton (sidebar + header + main content grid)
- Implement [business/$businessDescriptor/index.tsx](portal-v2/src/routes/business/$businessDescriptor/index.tsx): Business home/dashboard page showing overview cards (revenue, orders, customers, inventory), recent activity, quick actions, route loader prefetches dashboard analytics (staleTime: 5 minutes), content-aware skeleton (grid of stat cards + activity list pulse)
- Create [src/api/customer.ts](portal-v2/src/api/customer.ts): Port customer endpoints with query hooks (`useCustomersQuery`, `useCustomerQuery`, `useCreateCustomerMutation`, `useUpdateCustomerMutation`, `useDeleteCustomerMutation`), use centralized query keys with businessScoped flag, set staleTime: 30 seconds (business-critical data), implement optimistic updates with toast notification on rollback only
- Each business route: Route loader prefetches data with TanStack Query using `queryOptions`, render with responsive table/card views, implement search/filter/pagination with URL search params, Suspense boundary with content-aware skeleton matching page layout

### 8. Migrate atomic design component library with TanStack Forms and error boundaries

- Port atoms: [Button.tsx](portal-v2/src/components/atoms/Button.tsx), [Input.tsx](portal-v2/src/components/atoms/Input.tsx), [Modal.tsx](portal-v2/src/components/atoms/Modal.tsx), [Dialog.tsx](portal-v2/src/components/atoms/Dialog.tsx), [Badge.tsx](portal-v2/src/components/atoms/Badge.tsx), [Avatar.tsx](portal-v2/src/components/atoms/Avatar.tsx), [Skeleton.tsx](portal-v2/src/components/atoms/Skeleton.tsx)
- Create [ErrorBoundary.tsx](portal-v2/src/components/atoms/ErrorBoundary.tsx): Component-level error boundary with inline fallback UI (error icon, translated error message, smart retry button), smart retry mechanism (reset error boundary state + identify and refetch failed queries using queryClient.getQueryCache), maintains component space and layout, optional compact mode for smaller organisms, logs error to console in development
- Create TanStack Form field components with onBlur validation: [FormInput.tsx](portal-v2/src/components/atoms/FormInput.tsx), [FormTextarea.tsx](portal-v2/src/components/atoms/FormTextarea.tsx), [FormSelect.tsx](portal-v2/src/components/atoms/FormSelect.tsx), [FormCheckbox.tsx](portal-v2/src/components/atoms/FormCheckbox.tsx), [FormRadio.tsx](portal-v2/src/components/atoms/FormRadio.tsx), [FormToggle.tsx](portal-v2/src/components/atoms/FormToggle.tsx), [PasswordInput.tsx](portal-v2/src/components/atoms/PasswordInput.tsx) - integrate with TanStack Form field API (`field.state.value`, `field.handleChange`, `field.handleBlur`, `field.state.meta.errors`), validate onBlur by default
- Port molecules: [SearchInput.tsx](portal-v2/src/components/molecules/SearchInput.tsx), [Pagination.tsx](portal-v2/src/components/molecules/Pagination.tsx), [CustomerCard.tsx](portal-v2/src/components/molecules/CustomerCard.tsx), [LanguageSwitcher.tsx](portal-v2/src/components/molecules/LanguageSwitcher.tsx), [PhoneCodeSelect.tsx](portal-v2/src/components/molecules/PhoneCodeSelect.tsx), [CountrySelect.tsx](portal-v2/src/components/molecules/CountrySelect.tsx), [BottomSheet.tsx](portal-v2/src/components/molecules/BottomSheet.tsx), [BusinessSwitcher.tsx](portal-v2/src/components/molecules/BusinessSwitcher.tsx) (triggers businessStore.selectBusiness on change, invalidates queries), [UserMenu.tsx](portal-v2/src/components/molecules/UserMenu.tsx)
- Port organisms with ErrorBoundary wrapping: [LoginForm.tsx](portal-v2/src/components/organisms/LoginForm.tsx), [Sidebar.tsx](portal-v2/src/components/organisms/Sidebar.tsx), [Header.tsx](portal-v2/src/components/organisms/Header.tsx), [BottomNav.tsx](portal-v2/src/components/organisms/BottomNav.tsx), [Table.tsx](portal-v2/src/components/organisms/Table.tsx), [FilterButton.tsx](portal-v2/src/components/organisms/FilterButton.tsx) - each organism wrapped in ErrorBoundary with inline fallback, smart retry refetches organism-specific queries, error does not crash entire page
- Port templates: [DashboardLayout.tsx](portal-v2/src/components/templates/DashboardLayout.tsx) (composes Sidebar, Header, BottomNav organisms with individual error boundaries, prevents one failing component from breaking layout), [OnboardingLayout.tsx](portal-v2/src/components/templates/OnboardingLayout.tsx)
- Create content-aware skeleton components: [CustomerListSkeleton.tsx](portal-v2/src/components/atoms/skeletons/CustomerListSkeleton.tsx), [CustomerDetailSkeleton.tsx](portal-v2/src/components/atoms/skeletons/CustomerDetailSkeleton.tsx), [DashboardSkeleton.tsx](portal-v2/src/components/atoms/skeletons/DashboardSkeleton.tsx), [BusinessLayoutSkeleton.tsx](portal-v2/src/components/atoms/skeletons/BusinessLayoutSkeleton.tsx), [FormSkeleton.tsx](portal-v2/src/components/atoms/skeletons/FormSkeleton.tsx) - match actual component structure with pulse animations
- Update all components: Use TanStack Router's `Link` and `useNavigate`, use TanStack Store hooks (`useStore`) for state access, use centralized query keys for data fetching

### 9. Complete CRUD implementations with TanStack Query and Forms

- Create customer CRUD forms: Create/Edit Customer with TanStack Form (onBlur validation), fields for name, email, phone (with PhoneCodeSelect), address (with CountrySelect), social media handles, Zod validation schema for all fields (email format, phone validation, required fields), integrate with customer mutations
- Implement customer list [business/$businessDescriptor/customers/index.tsx](portal-v2/src/routes/business/$businessDescriptor/customers/index.tsx): Search/filter with debounced input (300ms), responsive table/card toggle (useMediaQuery hook), pagination with Pagination molecule and URL search params, infinite scroll option with InfiniteScroll molecule, empty states with CTA button, Suspense boundary with CustomerListSkeleton (content-aware: table headers + row pulses or card grid pulses based on view mode)
- Implement customer details [business/$businessDescriptor/customers/$customerId.tsx](portal-v2/src/routes/business/$businessDescriptor/customers/$customerId.tsx): Route loader prefetches customer with `useCustomerQuery` (staleTime: 30 seconds), display CustomerCard organism, edit in BottomSheet with TanStack Form, delete confirmation Modal, optimistic updates on mutations (update cache immediately, show toast on rollback only), Suspense boundary with CustomerDetailSkeleton (content-aware: customer card structure with pulse sections)
- Create mutation toast notifications: Success toasts with translated messages (`common:customer_created`, `common:customer_updated`, `common:customer_deleted`), error toasts with translateErrorAsync, RTL-aware positioning via useLanguage hook, 4 second auto-dismiss
- Add query invalidation: On mutation success, invalidate relevant query keys (`queryKeys.customers.list()`, `queryKeys.customers.detail(id)`), automatic background refetch of affected queries respecting staleTime, on business switch invalidate all customer queries via businessStore.selectBusiness action

### 10. Polish, optimize, and validate complete migration

- Migrate [src/routes/design-system.tsx](portal-v2/src/routes/design-system.tsx): Port component showcase page with all atoms, molecules, organisms organized by category, test variants (sizes, colors, states, RTL), include TanStack Form examples with onBlur validation demonstration, error boundary demonstrations (trigger button to throw errors, show inline recovery with smart retry), skeleton state examples (all content-aware skeletons), TanStack Store devtools demo section (dev-only)
- Configure route preloading: Set `defaultPreload: 'intent'` in [router.tsx](portal-v2/src/router.tsx), add `preload: 'render'` for critical routes (business home, customer list), test hover prefetching in network tab
- Optimize bundle size: Lazy load non-critical routes with TanStack Router's lazy loading, code split large organisms, analyze bundle with `vite build --mode analyze`, tree-shake unused daisyUI components via Tailwind v4 purge, verify TanStack Store devtools excluded from production bundle, target main chunk < 200KB gzipped
- Place Suspense boundaries strategically: Root outlet (app-level fallback with AppSkeleton), business layout outlet (business-level fallback with BusinessLayoutSkeleton), individual routes (content-aware skeletons matching page structure: CustomerListSkeleton, CustomerDetailSkeleton, DashboardSkeleton, FormSkeleton), avoid Suspense inside organisms (use error boundaries instead)
- Comprehensive testing: Authentication flow (login, logout, refresh, OAuth, session restore), onboarding flow (all steps, payment, session recovery, OAuth during onboarding, localStorage persistence), business flows (business switching triggers query invalidation, route navigation `/business/:descriptor`), customer CRUD (create, read, update, delete with optimistic updates and toast on rollback only), i18n (language switching, RTL layout, error translation, toast positioning), responsive design (mobile 375px, tablet 768px, desktop 1440px), error boundaries (trigger errors in each organism, verify inline recovery with smart retry refetches queries), form validation (all TanStack Forms with onBlur validation timing), store persistence (businessStore, metadataStore with 24h TTL auto-clear, onboardingStore), TanStack Store devtools (dev-only, inspect state changes in all stores, verify excluded from production build)
- Performance audit: Lighthouse score (target: 90+ performance, 100 accessibility), bundle size analysis (main chunk < 200KB gzipped, route chunks < 50KB each, verify devtools excluded from production), query cache efficiency (verify staleTime strategy reduces API calls, test business-switch invalidation clears relevant queries, check network tab for unnecessary requests), route prefetch effectiveness (hover links, monitor prefetch requests)
- Documentation: Update [README.md](portal-v2/README.md) with TanStack Router architecture, folder-based route structure documentation (singular `/business/:businessDescriptor`), centralized query key patterns with staleTime strategy table and businessScoped flag explanation, TanStack Store persistence plugin usage, TanStack Store devtools setup (dev-only, production exclusion), TanStack Form patterns with onBlur validation, component-level error boundary pattern with smart retry mechanism, Suspense boundary placement guidelines with content-aware skeleton strategy, business-switch query invalidation pattern, migration notes for future features
